{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from random import randint\n",
    "import numpy\n",
    "from tkinter import *\n",
    "from tkinter import filedialog, Text, Tk\n",
    "import os\n",
    "import tkinter as tk\n",
    "from PIL import Image, ImageTk\n",
    "from PIL import Image\n",
    "\n",
    "def upshift(a, index, n):\n",
    "    col = []\n",
    "    for j in range(len(a)):\n",
    "        col.append(a[j][index])\n",
    "    shiftCol = numpy.roll(col, -n)\n",
    "    for i in range(len(a)):\n",
    "        for j in range(len(a[0])):\n",
    "            if j == index:\n",
    "                a[i][j] = shiftCol[i]\n",
    "\n",
    "def downshift(a, index, n):\n",
    "    col = []\n",
    "    for j in range(len(a)):\n",
    "        col.append(a[j][index])\n",
    "    shiftCol = numpy.roll(col, n)\n",
    "    for i in range(len(a)):\n",
    "        for j in range(len(a[0])):\n",
    "            if j == index:\n",
    "                a[i][j] = shiftCol[i]\n",
    "\n",
    "def rotate180(n):\n",
    "    bits = \"{0:b}\".format(n)\n",
    "    return int(bits[::-1], 2)\n",
    "\n",
    "def encryption(im, pix):\n",
    "    # Obtaining the RGB matrices\n",
    "    r = []\n",
    "    g = []\n",
    "    b = []\n",
    "    for i in range(im.size[0]):\n",
    "        r.append([])\n",
    "        g.append([])\n",
    "        b.append([])\n",
    "        for j in range(im.size[1]):\n",
    "            rgbPerPixel = pix[i, j]\n",
    "            r[i].append(rgbPerPixel[0])\n",
    "            g[i].append(rgbPerPixel[1])\n",
    "            b[i].append(rgbPerPixel[2])\n",
    "    #Initial RGB Matrix Print\n",
    "    #print(\"\\nRGB Matrix: \")\n",
    "    #print(\"\\nR: \",r)\n",
    "    #print(\"\\nG: \",g)\n",
    "    #print(\"\\nB: \",b)\n",
    "\n",
    "\n",
    "    # M x N image matrix\n",
    "    m = im.size[0]  # rows\n",
    "    n = im.size[1]  # columns\n",
    "    \n",
    "\n",
    "    # Vectors Kr and Kc\n",
    "    alpha = 8\n",
    "    Kr = [randint(0, pow(2, alpha) - 1) for i in range(m)]\n",
    "    Kc = [randint(0, pow(2, alpha) - 1) for i in range(n)]\n",
    "\n",
    "    # Sub-key generation\n",
    "    def getKeyMatrix(key, message, keyMatrix):\n",
    "        k = 0\n",
    "        for i in range(len(message)):\n",
    "            for j in range(len(message)):\n",
    "                keyMatrix[i][j] = ord(key[k]) % 65\n",
    "                k += 1\n",
    "\n",
    "\n",
    "    def encrypt(messageVector, message, cipherMatrix, keyMatrix):\n",
    "        for i in range(len(message)):\n",
    "            for j in range(1):\n",
    "                cipherMatrix[i][j] = 0\n",
    "                for x in range(len(message)):\n",
    "                    cipherMatrix[i][j] += (keyMatrix[i][x] * messageVector[x][j])\n",
    "                    cipherMatrix[i][j] = cipherMatrix[i][j] % 26\n",
    "\n",
    "    def HillCipher(message, key):\n",
    "        keyMatrix = [[0] * (len(message)) for i in range(len(message))]\n",
    "        cipherMatrix = [[0] for i in range(len(message))]\n",
    "        getKeyMatrix(key, message, keyMatrix)\n",
    "        messageVector = [[0] for i in range(len(message))]\n",
    "        for i in range(len(message)):\n",
    "            messageVector[i][0] = ord(message[i]) % 65\n",
    "        encrypt(messageVector, message, cipherMatrix, keyMatrix)\n",
    "        CipherText = []\n",
    "        for i in range(len(message)):\n",
    "            CipherText.append(chr(cipherMatrix[i][0] + 65))\n",
    "        temp = []\n",
    "        for i in range(len(CipherText)):\n",
    "            temp.append(str(ord(CipherText[i]) - 65))\n",
    "        for i in range(len(temp)):\n",
    "            temp.append(temp[i][::-1])\n",
    "        arr = list(map(int, temp))\n",
    "        return arr\n",
    "\n",
    "    message = input(\"Enter the private key (3 lettered):\").upper()\n",
    "    key1 = HillCipher(message, \"GYBNQKURP\")\n",
    "    # key1=[15,14,7,51,71,7]\n",
    "    for i in range(3):\n",
    "        if key1[i] % 2 == 0:\n",
    "            key1[i] = key1[i] + 1\n",
    "        if 0 <= key1[i] <= 9:\n",
    "            key1[i + 3] = key1[i] * 10\n",
    "\n",
    "    # maximum number of iterations\n",
    "    ITER_MAX = 3\n",
    "\n",
    "    print('\\nVector Kr : \\n', Kr)\n",
    "    print('\\nVector Kc : \\n', Kc)\n",
    "\n",
    "    # key for encryption written into the file keys.txt\n",
    "    f = open('keys.txt', 'w+')\n",
    "    f.write('Vector Kr :\\n')\n",
    "    for a in Kr:\n",
    "        f.write(str(a) + '\\n')\n",
    "    f.write('Vector Kc :\\n')\n",
    "    for a in Kc:\n",
    "        f.write(str(a) + '\\n')\n",
    "    f.write('ITER_MAX :\\n')\n",
    "    f.write(str(ITER_MAX) + '\\n')\n",
    "\n",
    "    for iterations in range(ITER_MAX):\n",
    "        \n",
    "        #Circular Shift\n",
    "        # For each row\n",
    "        for i in range(m):\n",
    "            # right circular shift\n",
    "            r[i] = numpy.roll(r[i], key1[3])\n",
    "            g[i] = numpy.roll(g[i], key1[4])\n",
    "            b[i] = numpy.roll(b[i], key1[5])\n",
    "        # For each column\n",
    "        for i in range(n):\n",
    "            # up circular shift\n",
    "            upshift(r, i, key1[0])\n",
    "            upshift(g, i, key1[1])\n",
    "            upshift(b, i, key1[2])\n",
    "        #RGB Matrix After Circular Shift Print\n",
    "        #print(\"\\nRGB Matrix After Circular Shift: \")\n",
    "        #print(\"\\nR: \",r)\n",
    "        #print(\"\\nG: \",g)\n",
    "        #print(\"\\nB: \",b)\n",
    "        \n",
    "        # affine transformation\n",
    "        for i in range(m):\n",
    "            for j in range(n):\n",
    "                r[i][j] = (key1[0] * r[i][j] + key1[3]) % 256\n",
    "                g[i][j] = (key1[1] * g[i][j] + key1[4]) % 256\n",
    "                b[i][j] = (key1[2] * b[i][j] + key1[5]) % 256\n",
    "                \n",
    "        #RGB Matrix After Affine Transformation Print\n",
    "        #print(\"\\nRGB Matrix After Affine Transformation: \")\n",
    "        #print(\"\\nR: \",r)\n",
    "        #print(\"\\nG: \",g)\n",
    "        #print(\"\\nB: \",b)\n",
    "\n",
    "        #XOR operation\n",
    "        # For each row\n",
    "        for i in range(m):\n",
    "            for j in range(n):\n",
    "                if i % 2 == 1:\n",
    "                    r[i][j] = r[i][j] ^ Kc[j]\n",
    "                    g[i][j] = g[i][j] ^ Kc[j]\n",
    "                    b[i][j] = b[i][j] ^ Kc[j]\n",
    "                else:\n",
    "                    r[i][j] = r[i][j] ^ rotate180(Kc[j])\n",
    "                    g[i][j] = g[i][j] ^ rotate180(Kc[j])\n",
    "                    b[i][j] = b[i][j] ^ rotate180(Kc[j])\n",
    "        # For each column\n",
    "        for j in range(n):\n",
    "            for i in range(m):\n",
    "                if j % 2 == 0:\n",
    "                    r[i][j] = r[i][j] ^ Kr[i]\n",
    "                    g[i][j] = g[i][j] ^ Kr[i]\n",
    "                    b[i][j] = b[i][j] ^ Kr[i]\n",
    "                else:\n",
    "                    r[i][j] = r[i][j] ^ rotate180(Kr[i])\n",
    "                    g[i][j] = g[i][j] ^ rotate180(Kr[i])\n",
    "                    b[i][j] = b[i][j] ^ rotate180(Kr[i])\n",
    "        #RGB Matrix After XOR operation Print\n",
    "        #print(\"\\nRGB Matrix After XOR Operation: \")\n",
    "        #print(\"\\nR: \",r)\n",
    "        #print(\"\\nG: \",g)\n",
    "        #print(\"\\nB: \",b)\n",
    "        \n",
    "        for i in range(m):\n",
    "            for j in range(n):\n",
    "                pix[i, j] = (r[i][j], g[i][j], b[i][j])\n",
    "\n",
    "\n",
    "if __name__ == '__main__':\n",
    "\n",
    "    def saveimg(img):\n",
    "        img.save('/Users/Ritocheta/Desktop/Project/encrypted.png')\n",
    "        print(\"Success\")\n",
    "        exit(0)\n",
    "\n",
    "    def chooseFile():\n",
    "        fln = filedialog.askopenfilename(initialdir=os.getcwd(), title='Select Image', filetypes=((\"PNG file\", \"*.png\"),(\"JPG File\", \"*.jpg\"), (\"All Files\", \"*.*\")))\n",
    "        img = Image.open(fln)\n",
    "        pic = img.load()\n",
    "        encryption(img, pic)\n",
    "        saveimg(img)\n",
    "        exit()\n",
    "\n",
    "    root = Tk()\n",
    "    root.resizable(False, False)\n",
    "    dbg = root.cget('bg')\n",
    "    frm = Frame(root)\n",
    "    frm.pack(side=TOP, padx=15, pady=15)\n",
    "\n",
    "    text = Text(root)\n",
    "    text.tag_configure(\"center\", justify='center', font='Montserrat')\n",
    "    text.insert('1.0', \"Image Encryption\\n\\n\\n\")\n",
    "    text.tag_add(\"center\", \"1.0\", \"end\")\n",
    "    text.tag_config(\"center\", foreground=\"grey\")\n",
    "    text.pack()\n",
    "\n",
    "    btn = Button(frm, text=\"Browse Image\", command=chooseFile)\n",
    "    btn.configure(font='Montserrat')\n",
    "    btn.pack(side=tk.LEFT)\n",
    "    btn2 = Button(frm, text=\"Quit\", command=lambda: exit())\n",
    "    btn2.configure(font='Montserrat')\n",
    "    btn2.pack(side=tk.LEFT, padx=10, ipadx=10)\n",
    "\n",
    "    root.title(\"Rubik's Cube Algorithm\")\n",
    "    root.geometry(\"400x300\")\n",
    "    root.mainloop()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
